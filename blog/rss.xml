<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>laundro Blog</title>
        <link>https://usdevs.github.io/laundro/blog</link>
        <description>laundro Blog</description>
        <lastBuildDate>Sun, 19 Dec 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[Interacting with I2C Devices]]></title>
            <link>https://usdevs.github.io/laundro/blog/2021/12/19/interacting-with-i2c</link>
            <guid>Interacting with I2C Devices</guid>
            <pubDate>Sun, 19 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Reading the values off light sensors or more specifically in our case, Analog to Digital Convertors (ADC/ADS) is really trivial with the use of already available modules like Adafruit_Blinka or RPI.GPIO. But this takes away the understanding of how you would actually interact with a I2C device and the magic that happens under the hood. This post serves to demystify some of the magic by looking what exactly are the bytes that are we are sending to these I2C devices.]]></description>
            <content:encoded><![CDATA[<p>Reading the values off light sensors or more specifically in our case, Analog to Digital Convertors (ADC/ADS) is really trivial with the use of already available modules like <code>Adafruit_Blinka</code> or <code>RPI.GPIO</code>. But this takes away the understanding of how you would actually interact with a I2C device and the magic that happens under the hood. This post serves to demystify some of the magic by looking what exactly are the bytes that are we are sending to these I2C devices.</p><blockquote><p>As to how we will actually send the bytes to the I2C register would probably deserve another write-up of its own</p></blockquote><p>Since we will be working with ADC/ADS in this project, it would be nice to use the ADS we have (<code>ADS1015</code> &amp; <code>ADS1115</code>) as examples as to how we would generally interact with I2C devices. The goal of it is really to develop a good sense of what is happening when you call <code>chan.value</code> or <code>chan.voltage</code>.</p><p>:::note
I will not get too much into what exactly is the <a href="https://www.circuitbasics.com/basics-of-the-i2c-communication-protocol/">I2C Protocol</a>, but a good intuition to hold on to is that using I2C you can connect multiple peripheral devices (in our cases multiple ADS/ADC) to a single master device (e.g. RPI). And it achieves this by using the <code>SCL</code> (Clock Line) and <code>SDA</code> (Data Line) of the master and peripheral devices.
:::</p><p>The important thing to note is that every I2C device provides its own &quot;way&quot; of reading and writing, but I believe we are able to gain sufficient intuition of how all these works from exploring how we can read values off the <strong><code>ADS1015</code></strong>.</p><h2><code>ADS1015</code></h2><p>First, we will need to look at the <a href="https://www.ti.com/lit/ds/symlink/ads1015.pdf?ts=1639761824088&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FADS1015">datasheet</a> provided by the manufacturer of the <code>ADS1015</code>. It tells us what registers are available for us to interact with and how can we use these registers to get the values we want.</p><p>There are 4 registers (excluding Address Pointer Register) present in the <code>ADS1015</code>:</p><table><thead><tr><th>Register</th><th>Address</th><th>Description</th></tr></thead><tbody><tr><td>Address Pointer Register</td><td>-</td><td>(<code>8-bit</code>) You access the other registers through these registers. It stores the references to the other registers on the device</td></tr><tr><td>Conversion Register</td><td><code>0b00</code></td><td>(<code>16-bit</code>) Not the most intuitive name but this stores the last <strong>converted</strong> value. Basically it stores the input value we are interested in (e.g. value at <code>A0</code>)</td></tr><tr><td>Config Register</td><td><code>0b01</code></td><td>(<code>16-bit</code>) As the name suggests, this is the register where we set config parameters such as single-ended or continuous mode. This is also where we can set the data rate of the ADS.</td></tr><tr><td>Lo_Thresh Register</td><td><code>0b10</code></td><td><em>Not relevant as of now</em></td></tr><tr><td>Hi_Thresh Register</td><td><code>0b11</code></td><td><em>Not relevant as of now</em></td></tr></tbody></table><p>:::info
Some I2C device would have a <strong>Device ID</strong> register that stores the device information like manufacturer ID or an ID identifying the model of the device.</p><p><em>Initially I hoping that the ADS we have contains this register so that we can differentiate the between <code>ADS1015</code> and <code>ADS1115</code> without any human verification but oh well..</em>
:::</p><h3>Modes of Operation</h3><p>Before getting into reading the values we want, it is perhaps useful to know the different modes that the <code>ADS1015</code> operate in.</p><table><thead><tr><th>Modes</th><th>Description</th></tr></thead><tbody><tr><td><strong>Single-ended</strong></td><td>Does 1 conversion (1 reading) and subsequently powers down</td></tr><tr><td><strong>Continuous</strong></td><td>After setting it to continuous via the Config Register (more on this below), it goes on (as the name suggests) continuously converting values for our consumption</td></tr></tbody></table><blockquote><p>However, you will realise later on that, Continuous mode does not work well when we are switching between different input channels and getting readings at the same time.</p></blockquote><p><strong>Now to the fun part of setting registers and reading values</strong></p><h3>Configuring it to get what we want</h3><p>This is where the datasheet comes in because without it we will be clueless as to how the device work. Unlike software, it would be of much greater pain in comparsion to discover how a hardware device works under the hood without any documentation. To put it simply, we want to know what bytes (down to the bits) should we send to the Config Register of the device so that we can get what we want, and for us to know what bits should we send, we will need the datasheet.</p><p>As specified by the datasheet (refer to page 24), we will need to set the 16-bit Config register accordingly to what each bit represent.</p><p><img src="./assets/ads1015-config-reg.png" alt="ads1015-config-reg"/></p><blockquote><p>Full details can be found in page 24 of the datasheet</p></blockquote><p>But it is useful to point out that:</p><ol><li><p><code>MUX[2:0]</code> : Tells the device which input pins (<code>Ax</code>) are we interested in reading values off</p><ul><li><code>0b100</code> corresponds to <code>A0</code></li></ul></li><li><p><code>MODE</code> : <em>self explanatory</em></p></li><li><p><code>DR[2:0]</code> : Data rate of the device (how fast we want the device to sample the input pins)</p><ul><li>Likely only useful when it is in Continuous mode</li></ul></li></ol><p><em>So, lets say we have a light sensor attached to <code>A0</code> and we would want to read the value at that input pin...</em></p><p>The following will be the 16 bits that we will set in the Config Register:</p><pre><code>1 100 001 1 100 00011
</code></pre><blockquote><p>You can practically ignore the last 5 bits, it is all default configs that do not matter as of now</p></blockquote><h3>Setting the Config Register</h3><p>To set the config register, we will be using the built-in <code>i2c-tools</code> package in the RPI, which provides commands to read/write from/to I2C devices. It does not give us a magic command to get the values off the <code>ADS1015</code> like the <code>adafruit_blinka</code> module, we will have to do it manually ourselves, but the magic it possess the how it is able to send these bits via the SDA and SCL lines adhering to the the I2C protocol.</p><p>First we will need to know what the address of the <code>ADS1015</code>. By default a single ADS will be assigned to address <code>0x48</code> or <code>72</code> (in decimal).</p><p>:::info
You can change the address of a ADS1015 by connecting the <code>ADDR</code> pin to the SDA/SCL/GND lines</p><p><em>Details are in the datasheet</em>
:::</p><p>Next, we know that the Config Register is at <code>0b01</code>, and that is all we need to set the 16 bits we have built.</p><pre><code class="language-bash"># i2cset -y &lt;i2c-bus&gt; &lt;i2c-dev-addr&gt; &lt;i2c-dev-register-address&gt; &lt;16-bit-payload-hex&gt; &lt;mode&gt;
i2cset -y 1 0x48 0x1 0xC383 w
</code></pre><p><strong>Note that the hexadecimal of the 16-bit payload we built above is <code>0xC383</code></strong></p><p>:::info
<strong>i2c-bus</strong></p><p>You can find out what is the i2c-bus by <code>ls /dev | grep i2c</code> where you will get <code>i2c-x</code> as the result. <code>x</code> will be the i2c-bus number.</p><p><strong>i2c-dev-addr</strong></p><p>Now that you have the i2c-bus you can do <code>i2cdetect -y 1</code> and see which address is active. Note that the address is in hex representation.</p><p><strong>mode</strong></p><p><code>w</code> corresponds to writing a 16-byte data block. By default it only accepts a data range of 1 byte
:::</p><h3>Reading the Conversion Register</h3><p>Now that we have set the Config register, and if we already have a light sensor attached to it, we can read the value off the Conversion register.</p><pre><code class="language-bash"># i2cget -y &lt;i2c-bus&gt; &lt;i2c-dev-id&gt; &lt;i2c-dev-register-address&gt; &lt;mode&gt;
i2cget -y 1 0x48 0x0 w
</code></pre><p>:::warning
Results of <code>i2cget</code> is <strong>little endian</strong> (LSB comes first)
:::</p><p>You will get a hexadecimal return value from the command, and in my case at the time of testing (with a light sensor attached) I got the following value:</p><p><strong><code>0x5046</code></strong></p><p>Converting it to decimal (bearing in mind it is little endian) we get the value of <strong>18000</strong>. This value is what the raw ADS value that we get from <code>chan.value</code> using adafruit modules.</p><p><em>I have not figured out how the conversion to voltage work but from the <code>adafruit_ads1x15</code> module the conversion seems to be of such:</em></p><pre><code class="language-python"># https://github.com/adafruit/Adafruit_CircuitPython_ADS1x15/blob/e33ed60b8cc6bbd565fdf8080f0057965f816c6b/adafruit_ads1x15/analog_in.py#L58-L62
def voltage(self):
    # self.value is the raw ADS value
    volts = self.value * _ADS1X15_PGA_RANGE[self._ads.gain] / 32767
    return volts
</code></pre><blockquote><p>In the 16bit payload that we have used, we were using the default gain which corresponds to <code>+-4.096</code></p></blockquote><p>Therefore, the voltage value that we get would be <strong><code>(18000*4.096)/32767 = 2.25</code></strong></p><p>:::note
An important thing to note that in our 16-bit payload to the Config register we have to specify an input that we reading from, therefore to get the value of a different input we will need to set the Config register again, this time with the bits that corresponds to another input of the ADS1015.</p><p>Similarly, since we have set the device to be single-ended mode, to get the latest value we will need to do the same process again, setting the config register and reading the value off the conversion register. If we are in continuous mode, we do not need to set the config register after the first time and we can always just read the latest value off the conversion register, thus making the polling faster.</p><p><strong>In the case of reading multiple inputs, you will now realize that setting the ADS1015 to continuous mode is not very helpful since we will need to reset the config register to switch inputs</strong>
:::</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What happens when RPI Imager crashes in the middle of flashing?]]></title>
            <link>https://usdevs.github.io/laundro/blog/2021/12/04/rpi-imager-crash</link>
            <guid>What happens when RPI Imager crashes in the middle of flashing?</guid>
            <pubDate>Sat, 04 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[My experience with the M1 Chip has been awesome, seeing how much more efficient the battery is and how much faster my builds are. But it is these rare (debatable) incompatiblity issues that sometimes I wish I have stucked with a PC.]]></description>
            <content:encoded><![CDATA[<p>My experience with the M1 Chip has been awesome, seeing how much more efficient the battery is and how much faster my builds are. But it is these rare (debatable) incompatiblity issues that sometimes I wish I have stucked with a PC.</p><p>I was flashing a SD card with a RPI OS image on my mac when the imager reported a <em>write error</em> without any error code or additional hints. What followed immediately was that my SD card became <strong>uninitialized</strong>. This meant that my SD was no longer readable and the file system/partitions (in fact everything) was gone. At this point I thought it was a freak event, so I went to reformat it.</p><p>In the case where you faced the same thing, you can reformat the SD card with the following configs:</p><ul><li>File System Type: <strong>MS-DOS(FAT-32)</strong></li><li>Partition Scheme: <strong>Master Boot Record(MBR)</strong></li></ul><div><div value="win" label="Windows" default=""><ol><li>Right click your SD-card</li><li>Reformat</li><li>Choose <b>exFAT</b> as File System</li></ol></div><div value="mac" label="Mac"><ol><li>Open <i>Disk Utility</i></li><li>Select the uninitialized disk corresponding to your SD-card</li><li>Choose <b>MS-DOS(FAT)</b> as File System Type</li><li>Choose <b>Master Boot Record</b> as Partition Scheme</li></ol></div></div><p>I fired up the Imager again and gave it another shot. It didn&#x27;t work so like every programmer I reformatted it again and tried to flash it again with the Imager. This time the progress bar went to up around <code>17%</code> (previously it failed at <code>3%</code>), so I was rather hopeful, but after a celebratory trip to the water cooler, the same error popped up when I came back.</p><p>Perhaps it was a problem with the Imager so I tried to flash it manually. (you can get a comprehensive guide on how to do that <a href="https://www.raspberrypi.com/documentation/computers/getting-started.html#installing-images-on-mac-os">here</a>) The process ended up with no errors and after doing a sanity check to see if I have actually got data onto the disk (SD-card), I thought it worked.</p><pre><code>kernel panic-not syncing: VFS: unable to mount root fs on unknown-block(179,2)
</code></pre><p>While booting up, the kernel panicked and so did I. To put it simply, the error had something to do with the kernel not being able to pick up the right partition of the file system. Followed some fixes but after rounds of reformatting and flashing, it still didn&#x27;t seem to work.</p><p>At this point you are probably expecting I found a fix... well technically I did but it was more of avoiding this specific problem. I went back to my old <code>win</code> PC and did the whole process again. </p><p><strong>It worked.</strong></p><p>I will probably find some time in the future to look more this but I guess the journey that a RPI Imager crashing in the middle of flashing took me on made me appreciate <code>win</code> more for its convenience and got me disappointed at engineers&#x27; lack of effort to support M1 hardware even after more than a year since its launch.</p>]]></content:encoded>
        </item>
    </channel>
</rss>