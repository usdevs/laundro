<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.9">
<link rel="alternate" type="application/rss+xml" href="/laundro/blog/rss.xml" title="laundro RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/laundro/blog/atom.xml" title="laundro Atom Feed"><title data-react-helmet="true">Interacting with I2C Devices | laundro</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://usdevs.github.io/laundro/blog/2021/12/19/interacting-with-i2c"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="Interacting with I2C Devices | laundro"><meta data-react-helmet="true" name="description" content="Reading the values off light sensors or more specifically in our case, Analog to Digital Convertors (ADC/ADS) is really trivial with the use of already available modules like Adafruit_Blinka or RPI.GPIO. But this takes away the understanding of how you would actually interact with a I2C device and the magic that happens under the hood. This post serves to demystify some of the magic by looking what exactly are the bytes that are we are sending to these I2C devices."><meta data-react-helmet="true" property="og:description" content="Reading the values off light sensors or more specifically in our case, Analog to Digital Convertors (ADC/ADS) is really trivial with the use of already available modules like Adafruit_Blinka or RPI.GPIO. But this takes away the understanding of how you would actually interact with a I2C device and the magic that happens under the hood. This post serves to demystify some of the magic by looking what exactly are the bytes that are we are sending to these I2C devices."><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2021-12-19T00:00:00.000Z"><meta data-react-helmet="true" property="article:author" content="https://github.com/shenyih0ng"><meta data-react-helmet="true" property="article:tag" content="cool-stuff"><link data-react-helmet="true" rel="shortcut icon" href="/laundro/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://usdevs.github.io/laundro/blog/2021/12/19/interacting-with-i2c"><link data-react-helmet="true" rel="alternate" href="https://usdevs.github.io/laundro/blog/2021/12/19/interacting-with-i2c" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://usdevs.github.io/laundro/blog/2021/12/19/interacting-with-i2c" hreflang="x-default"><link rel="stylesheet" href="/laundro/assets/css/styles.739d1d06.css">
<link rel="preload" href="/laundro/assets/js/runtime~main.8f6e23c9.js" as="script">
<link rel="preload" href="/laundro/assets/js/main.9aa8e547.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/laundro/"><div class="navbar__logo"><img src="/laundro/img/logo-dark.svg" alt="laundro" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/laundro/img/logo-light.svg" alt="laundro" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">laundro</b></a><a class="navbar__item navbar__link" href="/laundro/">Documentation</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/laundro/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/usdevs/laundro/tree/docs" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">ðŸŒœ</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">ðŸŒž</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_q+wC thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_9G5K margin-bottom--md">Recent posts</div><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a aria-current="page" class="sidebarItemLink_zyXk sidebarItemLinkActive_wcJs" href="/laundro/blog/2021/12/19/interacting-with-i2c">Interacting with I2C Devices</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/laundro/blog/2021/12/04/rpi-imager-crash">What happens when RPI Imager crashes in the middle of flashing?</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_d4p0" itemprop="headline">Interacting with I2C Devices</h1><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-12-19T00:00:00.000Z" itemprop="datePublished">December 19, 2021</time> Â· <!-- -->8 min read</div><div class="row margin-top--md margin-bottom--sm"><div class="col col--6 authorCol_8c0z"><div class="avatar margin-bottom--sm"><a href="https://github.com/shenyih0ng" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_9q7L" src="https://github.com/shenyih0ng.png" alt="yihong"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/shenyih0ng" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">yihong</span></a></div><small class="avatar__subtitle" itemprop="description">Contributor</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>Reading the values off light sensors or more specifically in our case, Analog to Digital Convertors (ADC/ADS) is really trivial with the use of already available modules like <code>Adafruit_Blinka</code> or <code>RPI.GPIO</code>. But this takes away the understanding of how you would actually interact with a I2C device and the magic that happens under the hood. This post serves to demystify some of the magic by looking what exactly are the bytes that are we are sending to these I2C devices.</p><blockquote><p>As to how we will actually send the bytes to the I2C register would probably deserve another write-up of its own</p></blockquote><p>Since we will be working with ADC/ADS in this project, it would be nice to use the ADS we have (<code>ADS1015</code> &amp; <code>ADS1115</code>) as examples as to how we would generally interact with I2C devices. The goal of it is really to develop a good sense of what is happening when you call <code>chan.value</code> or <code>chan.voltage</code>.</p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>I will not get too much into what exactly is the <a href="https://www.circuitbasics.com/basics-of-the-i2c-communication-protocol/" target="_blank" rel="noopener noreferrer">I2C Protocol</a>, but a good intuition to hold on to is that using I2C you can connect multiple peripheral devices (in our cases multiple ADS/ADC) to a single master device (e.g. RPI). And it achieves this by using the <code>SCL</code> (Clock Line) and <code>SDA</code> (Data Line) of the master and peripheral devices.</p></div></div><p>The important thing to note is that every I2C device provides its own &quot;way&quot; of reading and writing, but I believe we are able to gain sufficient intuition of how all these works from exploring how we can read values off the <strong><code>ADS1015</code></strong>.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="ads1015"><code>ADS1015</code><a aria-hidden="true" class="hash-link" href="#ads1015" title="Direct link to heading">â€‹</a></h2><p>First, we will need to look at the <a href="https://www.ti.com/lit/ds/symlink/ads1015.pdf?ts=1639761824088&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FADS1015" target="_blank" rel="noopener noreferrer">datasheet</a> provided by the manufacturer of the <code>ADS1015</code>. It tells us what registers are available for us to interact with and how can we use these registers to get the values we want.</p><p>There are 4 registers (excluding Address Pointer Register) present in the <code>ADS1015</code>:</p><table><thead><tr><th>Register</th><th>Address</th><th>Description</th></tr></thead><tbody><tr><td>Address Pointer Register</td><td>-</td><td>(<code>8-bit</code>) You access the other registers through these registers. It stores the references to the other registers on the device</td></tr><tr><td>Conversion Register</td><td><code>0b00</code></td><td>(<code>16-bit</code>) Not the most intuitive name but this stores the last <strong>converted</strong> value. Basically it stores the input value we are interested in (e.g. value at <code>A0</code>)</td></tr><tr><td>Config Register</td><td><code>0b01</code></td><td>(<code>16-bit</code>) As the name suggests, this is the register where we set config parameters such as single-ended or continuous mode. This is also where we can set the data rate of the ADS.</td></tr><tr><td>Lo_Thresh Register</td><td><code>0b10</code></td><td><em>Not relevant as of now</em></td></tr><tr><td>Hi_Thresh Register</td><td><code>0b11</code></td><td><em>Not relevant as of now</em></td></tr></tbody></table><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>Some I2C device would have a <strong>Device ID</strong> register that stores the device information like manufacturer ID or an ID identifying the model of the device.</p><p><em>Initially I hoping that the ADS we have contains this register so that we can differentiate the between <code>ADS1015</code> and <code>ADS1115</code> without any human verification but oh well..</em></p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="modes-of-operation">Modes of Operation<a aria-hidden="true" class="hash-link" href="#modes-of-operation" title="Direct link to heading">â€‹</a></h3><p>Before getting into reading the values we want, it is perhaps useful to know the different modes that the <code>ADS1015</code> operate in.</p><table><thead><tr><th>Modes</th><th>Description</th></tr></thead><tbody><tr><td><strong>Single-ended</strong></td><td>Does 1 conversion (1 reading) and subsequently powers down</td></tr><tr><td><strong>Continuous</strong></td><td>After setting it to continuous via the Config Register (more on this below), it goes on (as the name suggests) continuously converting values for our consumption</td></tr></tbody></table><blockquote><p>However, you will realise later on that, Continuous mode does not work well when we are switching between different input channels and getting readings at the same time.</p></blockquote><p><strong>Now to the fun part of setting registers and reading values</strong></p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="configuring-it-to-get-what-we-want">Configuring it to get what we want<a aria-hidden="true" class="hash-link" href="#configuring-it-to-get-what-we-want" title="Direct link to heading">â€‹</a></h3><p>This is where the datasheet comes in because without it we will be clueless as to how the device work. Unlike software, it would be of much greater pain in comparsion to discover how a hardware device works under the hood without any documentation. To put it simply, we want to know what bytes (down to the bits) should we send to the Config Register of the device so that we can get what we want, and for us to know what bits should we send, we will need the datasheet.</p><p>As specified by the datasheet (refer to page 24), we will need to set the 16-bit Config register accordingly to what each bit represent.</p><p><img alt="ads1015-config-reg" src="/laundro/assets/images/ads1015-config-reg-75ec76676334443ac846dafcff5bd8f7.png"></p><blockquote><p>Full details can be found in page 24 of the datasheet</p></blockquote><p>But it is useful to point out that:</p><ol><li><p><code>MUX[2:0]</code> : Tells the device which input pins (<code>Ax</code>) are we interested in reading values off</p><ul><li><code>0b100</code> corresponds to <code>A0</code></li></ul></li><li><p><code>MODE</code> : <em>self explanatory</em></p></li><li><p><code>DR[2:0]</code> : Data rate of the device (how fast we want the device to sample the input pins)</p><ul><li>Likely only useful when it is in Continuous mode</li></ul></li></ol><p><em>So, lets say we have a light sensor attached to <code>A0</code> and we would want to read the value at that input pin...</em></p><p>The following will be the 16 bits that we will set in the Config Register:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">1 100 001 1 100 00011</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><blockquote><p>You can practically ignore the last 5 bits, it is all default configs that do not matter as of now</p></blockquote><h3 class="anchor anchorWithStickyNavbar_y2LR" id="setting-the-config-register">Setting the Config Register<a aria-hidden="true" class="hash-link" href="#setting-the-config-register" title="Direct link to heading">â€‹</a></h3><p>To set the config register, we will be using the built-in <code>i2c-tools</code> package in the RPI, which provides commands to read/write from/to I2C devices. It does not give us a magic command to get the values off the <code>ADS1015</code> like the <code>adafruit_blinka</code> module, we will have to do it manually ourselves, but the magic it possess the how it is able to send these bits via the SDA and SCL lines adhering to the the I2C protocol.</p><p>First we will need to know what the address of the <code>ADS1015</code>. By default a single ADS will be assigned to address <code>0x48</code> or <code>72</code> (in decimal).</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>You can change the address of a ADS1015 by connecting the <code>ADDR</code> pin to the SDA/SCL/GND lines</p><p><em>Details are in the datasheet</em></p></div></div><p>Next, we know that the Config Register is at <code>0b01</code>, and that is all we need to set the 16 bits we have built.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI bash"><pre tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># i2cset -y &lt;i2c-bus&gt; &lt;i2c-dev-addr&gt; &lt;i2c-dev-register-address&gt; &lt;16-bit-payload-hex&gt; &lt;mode&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i2cset -y </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"> 0x48 0x1 0xC383 w</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>Note that the hexadecimal of the 16-bit payload we built above is <code>0xC383</code></strong></p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><strong>i2c-bus</strong></p><p>You can find out what is the i2c-bus by <code>ls /dev | grep i2c</code> where you will get <code>i2c-x</code> as the result. <code>x</code> will be the i2c-bus number.</p><p><strong>i2c-dev-addr</strong></p><p>Now that you have the i2c-bus you can do <code>i2cdetect -y 1</code> and see which address is active. Note that the address is in hex representation.</p><p><strong>mode</strong></p><p><code>w</code> corresponds to writing a 16-byte data block. By default it only accepts a data range of 1 byte</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="reading-the-conversion-register">Reading the Conversion Register<a aria-hidden="true" class="hash-link" href="#reading-the-conversion-register" title="Direct link to heading">â€‹</a></h3><p>Now that we have set the Config register, and if we already have a light sensor attached to it, we can read the value off the Conversion register.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI bash"><pre tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># i2cget -y &lt;i2c-bus&gt; &lt;i2c-dev-id&gt; &lt;i2c-dev-register-address&gt; &lt;mode&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i2cget -y </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"> 0x48 0x0 w</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="admonition admonition-warning alert alert--danger"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>warning</h5></div><div class="admonition-content"><p>Results of <code>i2cget</code> is <strong>little endian</strong> (LSB comes first)</p></div></div><p>You will get a hexadecimal return value from the command, and in my case at the time of testing (with a light sensor attached) I got the following value:</p><p><strong><code>0x5046</code></strong></p><p>Converting it to decimal (bearing in mind it is little endian) we get the value of <strong>18000</strong>. This value is what the raw ADS value that we get from <code>chan.value</code> using adafruit modules.</p><p><em>I have not figured out how the conversion to voltage work but from the <code>adafruit_ads1x15</code> module the conversion seems to be of such:</em></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI python"><pre tabindex="0" class="prism-code language-python codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># https://github.com/adafruit/Adafruit_CircuitPython_ADS1x15/blob/e33ed60b8cc6bbd565fdf8080f0057965f816c6b/adafruit_ads1x15/analog_in.py#L58-L62</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">voltage</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">self</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic"># self.value is the raw ADS value</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volts </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">value </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> _ADS1X15_PGA_RANGE</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">_ads</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">gain</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">/</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">32767</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> volts</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><blockquote><p>In the 16bit payload that we have used, we were using the default gain which corresponds to <code>+-4.096</code></p></blockquote><p>Therefore, the voltage value that we get would be <strong><code>(18000*4.096)/32767 = 2.25</code></strong></p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>An important thing to note that in our 16-bit payload to the Config register we have to specify an input that we reading from, therefore to get the value of a different input we will need to set the Config register again, this time with the bits that corresponds to another input of the ADS1015.</p><p>Similarly, since we have set the device to be single-ended mode, to get the latest value we will need to do the same process again, setting the config register and reading the value off the conversion register. If we are in continuous mode, we do not need to set the config register after the first time and we can always just read the latest value off the conversion register, thus making the polling faster.</p><p><strong>In the case of reading multiple inputs, you will now realize that setting the ADS1015 to continuous mode is not very helpful since we will need to reset the config register to switch inputs</strong></p></div></div></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_xD8n"><div class="col"><b>Tags:</b><ul class="tags_NBRY padding--none margin-left--sm"><li class="tag_F03v"><a class="tag_WK-t tagRegular_LXbV" href="/laundro/blog/tags/cool-stuff">cool-stuff</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/usdevs/laundro/tree/docs/blog/2021-12-19-interacting-with-i2c.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/laundro/blog/2021/12/04/rpi-imager-crash"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">What happens when RPI Imager crashes in the middle of flashing?<!-- --> Â»</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#ads1015" class="table-of-contents__link toc-highlight"><code>ADS1015</code></a><ul><li><a href="#modes-of-operation" class="table-of-contents__link toc-highlight">Modes of Operation</a></li><li><a href="#configuring-it-to-get-what-we-want" class="table-of-contents__link toc-highlight">Configuring it to get what we want</a></li><li><a href="#setting-the-config-register" class="table-of-contents__link toc-highlight">Setting the Config Register</a></li><li><a href="#reading-the-conversion-register" class="table-of-contents__link toc-highlight">Reading the Conversion Register</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/laundro/">Documentation</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/laundro/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/usdevs/laundro/tree/docs" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"></div></div></footer></div>
<script src="/laundro/assets/js/runtime~main.8f6e23c9.js"></script>
<script src="/laundro/assets/js/main.9aa8e547.js"></script>
</body>
</html>