"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[615],{2104:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"Interacting with I2C Devices","metadata":{"permalink":"/laundro/blog/2021/12/19/interacting-with-i2c","editUrl":"https://github.com/usdevs/laundro/tree/docs/blog/2021-12-19-interacting-with-i2c.md","source":"@site/blog/2021-12-19-interacting-with-i2c.md","title":"Interacting with I2C Devices","description":"Reading the values off light sensors or more specifically in our case, Analog to Digital Convertors (ADC/ADS) is really trivial with the use of already available modules like Adafruit_Blinka or RPI.GPIO. But this takes away the understanding of how you would actually interact with a I2C device and the magic that happens under the hood. This post serves to demystify some of the magic by looking what exactly are the bytes that are we are sending to these I2C devices.","date":"2021-12-19T00:00:00.000Z","formattedDate":"December 19, 2021","tags":[{"label":"cool-stuff","permalink":"/laundro/blog/tags/cool-stuff"}],"readingTime":7.66,"truncated":true,"authors":[{"name":"yihong","title":"Contributor","url":"https://github.com/shenyih0ng","imageURL":"https://github.com/shenyih0ng.png","key":"yihong"}],"nextItem":{"title":"What happens when RPI Imager crashes in the middle of flashing?","permalink":"/laundro/blog/2021/12/04/rpi-imager-crash"}},"content":"Reading the values off light sensors or more specifically in our case, Analog to Digital Convertors (ADC/ADS) is really trivial with the use of already available modules like `Adafruit_Blinka` or `RPI.GPIO`. But this takes away the understanding of how you would actually interact with a I2C device and the magic that happens under the hood. This post serves to demystify some of the magic by looking what exactly are the bytes that are we are sending to these I2C devices.\\n\\n> As to how we will actually send the bytes to the I2C register would probably deserve another write-up of its own\\n\\n\x3c!--truncate--\x3e\\n\\nSince we will be working with ADC/ADS in this project, it would be nice to use the ADS we have (`ADS1015` & `ADS1115`) as examples as to how we would generally interact with I2C devices. The goal of it is really to develop a good sense of what is happening when you call `chan.value` or `chan.voltage`.\\n\\n:::note\\nI will not get too much into what exactly is the [I2C Protocol](https://www.circuitbasics.com/basics-of-the-i2c-communication-protocol/), but a good intuition to hold on to is that using I2C you can connect multiple peripheral devices (in our cases multiple ADS/ADC) to a single master device (e.g. RPI). And it achieves this by using the `SCL` (Clock Line) and `SDA` (Data Line) of the master and peripheral devices.\\n:::\\n\\nThe important thing to note is that every I2C device provides its own \\"way\\" of reading and writing, but I believe we are able to gain sufficient intuition of how all these works from exploring how we can read values off the **`ADS1015`**.\\n\\n## `ADS1015`\\n\\nFirst, we will need to look at the [datasheet](https://www.ti.com/lit/ds/symlink/ads1015.pdf?ts=1639761824088&ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FADS1015) provided by the manufacturer of the `ADS1015`. It tells us what registers are available for us to interact with and how can we use these registers to get the values we want.\\n\\nThere are 4 registers (excluding Address Pointer Register) present in the `ADS1015`:\\n\\n| Register                 | Address | Description                                                                                                                                                                           |\\n| ------------------------ | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| Address Pointer Register | -       | (`8-bit`) You access the other registers through these registers. It stores the references to the other registers on the device                                                       |\\n| Conversion Register      | `0b00`  | (`16-bit`) Not the most intuitive name but this stores the last **converted** value. Basically it stores the input value we are interested in (e.g. value at `A0`)                    |\\n| Config Register          | `0b01`  | (`16-bit`) As the name suggests, this is the register where we set config parameters such as single-ended or continuous mode. This is also where we can set the data rate of the ADS. |\\n| Lo_Thresh Register       | `0b10`  | _Not relevant as of now_                                                                                                                                                              |\\n| Hi_Thresh Register       | `0b11`  | _Not relevant as of now_                                                                                                                                                              |\\n\\n:::info\\nSome I2C device would have a **Device ID** register that stores the device information like manufacturer ID or an ID identifying the model of the device.\\n\\n_Initially I hoping that the ADS we have contains this register so that we can differentiate the between `ADS1015` and `ADS1115` without any human verification but oh well.._\\n:::\\n\\n### Modes of Operation\\n\\nBefore getting into reading the values we want, it is perhaps useful to know the different modes that the `ADS1015` operate in.\\n\\n| Modes            | Description                                                                                                                                                       |\\n| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| **Single-ended** | Does 1 conversion (1 reading) and subsequently powers down                                                                                                        |\\n| **Continuous**   | After setting it to continuous via the Config Register (more on this below), it goes on (as the name suggests) continuously converting values for our consumption |\\n\\n> However, you will realise later on that, Continuous mode does not work well when we are switching between different input channels and getting readings at the same time.\\n\\n**Now to the fun part of setting registers and reading values**\\n\\n### Configuring it to get what we want\\n\\nThis is where the datasheet comes in because without it we will be clueless as to how the device work. Unlike software, it would be of much greater pain in comparsion to discover how a hardware device works under the hood without any documentation. To put it simply, we want to know what bytes (down to the bits) should we send to the Config Register of the device so that we can get what we want, and for us to know what bits should we send, we will need the datasheet.\\n\\nAs specified by the datasheet (refer to page 24), we will need to set the 16-bit Config register accordingly to what each bit represent.\\n\\n![ads1015-config-reg](./assets/ads1015-config-reg.png)\\n\\n> Full details can be found in page 24 of the datasheet\\n\\nBut it is useful to point out that:\\n\\n1. `MUX[2:0]` : Tells the device which input pins (`Ax`) are we interested in reading values off\\n    - `0b100` corresponds to `A0`\\n\\n2. `MODE` : _self explanatory_\\n\\n3. `DR[2:0]` : Data rate of the device (how fast we want the device to sample the input pins)\\n    - Likely only useful when it is in Continuous mode\\n\\n_So, lets say we have a light sensor attached to `A0` and we would want to read the value at that input pin..._\\n\\nThe following will be the 16 bits that we will set in the Config Register:\\n\\n```\\n1 100 001 1 100 00011\\n```\\n\\n> You can practically ignore the last 5 bits, it is all default configs that do not matter as of now\\n\\n### Setting the Config Register\\n\\nTo set the config register, we will be using the built-in `i2c-tools` package in the RPI, which provides commands to read/write from/to I2C devices. It does not give us a magic command to get the values off the `ADS1015` like the `adafruit_blinka` module, we will have to do it manually ourselves, but the magic it possess the how it is able to send these bits via the SDA and SCL lines adhering to the the I2C protocol.\\n\\nFirst we will need to know what the address of the `ADS1015`. By default a single ADS will be assigned to address `0x48` or `72` (in decimal).\\n\\n:::info\\nYou can change the address of a ADS1015 by connecting the `ADDR` pin to the SDA/SCL/GND lines\\n\\n_Details are in the datasheet_\\n:::\\n\\nNext, we know that the Config Register is at `0b01`, and that is all we need to set the 16 bits we have built.\\n\\n```bash\\n# i2cset -y <i2c-bus> <i2c-dev-addr> <i2c-dev-register-address> <16-bit-payload-hex> <mode>\\ni2cset -y 1 0x48 0x1 0xC383 w\\n```\\n\\n**Note that the hexadecimal of the 16-bit payload we built above is `0xC383`**\\n\\n:::info\\n**i2c-bus**\\n\\nYou can find out what is the i2c-bus by `ls /dev | grep i2c` where you will get `i2c-x` as the result. `x` will be the i2c-bus number.\\n\\n**i2c-dev-addr**\\n\\nNow that you have the i2c-bus you can do `i2cdetect -y 1` and see which address is active. Note that the address is in hex representation.\\n\\n**mode**\\n\\n`w` corresponds to writing a 16-byte data block. By default it only accepts a data range of 1 byte\\n:::\\n\\n### Reading the Conversion Register\\n\\nNow that we have set the Config register, and if we already have a light sensor attached to it, we can read the value off the Conversion register.\\n\\n```bash\\n# i2cget -y <i2c-bus> <i2c-dev-id> <i2c-dev-register-address> <mode>\\ni2cget -y 1 0x48 0x0 w\\n```\\n\\n:::warning\\nResults of `i2cget` is **little endian** (LSB comes first)\\n:::\\n\\nYou will get a hexadecimal return value from the command, and in my case at the time of testing (with a light sensor attached) I got the following value:\\n\\n**`0x5046`**\\n\\nConverting it to decimal (bearing in mind it is little endian) we get the value of **18000**. This value is what the raw ADS value that we get from `chan.value` using adafruit modules.\\n\\n_I have not figured out how the conversion to voltage work but from the `adafruit_ads1x15` module the conversion seems to be of such:_\\n\\n```python\\n# https://github.com/adafruit/Adafruit_CircuitPython_ADS1x15/blob/e33ed60b8cc6bbd565fdf8080f0057965f816c6b/adafruit_ads1x15/analog_in.py#L58-L62\\ndef voltage(self):\\n    # self.value is the raw ADS value\\n    volts = self.value * _ADS1X15_PGA_RANGE[self._ads.gain] / 32767\\n    return volts\\n```\\n\\n> In the 16bit payload that we have used, we were using the default gain which corresponds to `+-4.096`\\n\\nTherefore, the voltage value that we get would be **`(18000*4.096)/32767 = 2.25`**\\n\\n:::note\\nAn important thing to note that in our 16-bit payload to the Config register we have to specify an input that we reading from, therefore to get the value of a different input we will need to set the Config register again, this time with the bits that corresponds to another input of the ADS1015.\\n\\nSimilarly, since we have set the device to be single-ended mode, to get the latest value we will need to do the same process again, setting the config register and reading the value off the conversion register. If we are in continuous mode, we do not need to set the config register after the first time and we can always just read the latest value off the conversion register, thus making the polling faster.\\n\\n**In the case of reading multiple inputs, you will now realize that setting the ADS1015 to continuous mode is not very helpful since we will need to reset the config register to switch inputs**\\n:::"},{"id":"What happens when RPI Imager crashes in the middle of flashing?","metadata":{"permalink":"/laundro/blog/2021/12/04/rpi-imager-crash","editUrl":"https://github.com/usdevs/laundro/tree/docs/blog/2021-12-04-rpi-imager-crash.md","source":"@site/blog/2021-12-04-rpi-imager-crash.md","title":"What happens when RPI Imager crashes in the middle of flashing?","description":"My experience with the M1 Chip has been awesome, seeing how much more efficient the battery is and how much faster my builds are. But it is these rare (debatable) incompatiblity issues that sometimes I wish I have stucked with a PC.","date":"2021-12-04T00:00:00.000Z","formattedDate":"December 4, 2021","tags":[{"label":"feelsbad","permalink":"/laundro/blog/tags/feelsbad"}],"readingTime":2.465,"truncated":true,"authors":[{"name":"yihong","title":"Contributor","url":"https://github.com/shenyih0ng","imageURL":"https://github.com/shenyih0ng.png","key":"yihong"}],"prevItem":{"title":"Interacting with I2C Devices","permalink":"/laundro/blog/2021/12/19/interacting-with-i2c"}},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\nMy experience with the M1 Chip has been awesome, seeing how much more efficient the battery is and how much faster my builds are. But it is these rare (debatable) incompatiblity issues that sometimes I wish I have stucked with a PC.\\n\\n\x3c!--truncate--\x3e\\n\\nI was flashing a SD card with a RPI OS image on my mac when the imager reported a _write error_ without any error code or additional hints. What followed immediately was that my SD card became **uninitialized**. This meant that my SD was no longer readable and the file system/partitions (in fact everything) was gone. At this point I thought it was a freak event, so I went to reformat it.\\n\\nIn the case where you faced the same thing, you can reformat the SD card with the following configs:\\n\\n- File System Type: **MS-DOS(FAT-32)**\\n- Partition Scheme: **Master Boot Record(MBR)**\\n\\n<Tabs>\\n  <TabItem value=\\"win\\" label=\\"Windows\\" default>\\n  <ol>\\n    <li>Right click your SD-card</li>\\n    <li>Reformat</li>\\n    <li>Choose <b>exFAT</b> as File System</li>\\n  </ol> \\n  </TabItem>\\n  <TabItem value=\\"mac\\" label=\\"Mac\\">\\n  <ol>\\n    <li>Open <i>Disk Utility</i></li>\\n    <li>Select the uninitialized disk corresponding to your SD-card</li>\\n    <li>Choose <b>MS-DOS(FAT)</b> as File System Type</li>\\n    <li>Choose <b>Master Boot Record</b> as Partition Scheme</li>\\n  </ol> \\n  </TabItem>\\n</Tabs>\\n\\nI fired up the Imager again and gave it another shot. It didn\'t work so like every programmer I reformatted it again and tried to flash it again with the Imager. This time the progress bar went to up around `17%` (previously it failed at `3%`), so I was rather hopeful, but after a celebratory trip to the water cooler, the same error popped up when I came back.\\n\\nPerhaps it was a problem with the Imager so I tried to flash it manually. (you can get a comprehensive guide on how to do that [here](https://www.raspberrypi.com/documentation/computers/getting-started.html#installing-images-on-mac-os)) The process ended up with no errors and after doing a sanity check to see if I have actually got data onto the disk (SD-card), I thought it worked.\\n\\n```\\nkernel panic-not syncing: VFS: unable to mount root fs on unknown-block(179,2)\\n```\\n\\nWhile booting up, the kernel panicked and so did I. To put it simply, the error had something to do with the kernel not being able to pick up the right partition of the file system. Followed some fixes but after rounds of reformatting and flashing, it still didn\'t seem to work.\\n\\nAt this point you are probably expecting I found a fix... well technically I did but it was more of avoiding this specific problem. I went back to my old `win` PC and did the whole process again. \\n\\n**It worked.**\\n\\nI will probably find some time in the future to look more this but I guess the journey that a RPI Imager crashing in the middle of flashing took me on made me appreciate `win` more for its convenience and got me disappointed at engineers\' lack of effort to support M1 hardware even after more than a year since its launch."}]}')}}]);